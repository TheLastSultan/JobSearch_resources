# BST Whiteboarding

## Warm Up

### [Traversals](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)

* Implement Post Order Traversal
  * Left, Right, Root
* Implement Pre Order Traversal
  * Root, Left, Right
  
## `lca`

In a binary search tree, an *ancestor* of a `example_node` is a node that is on a higher level than `example_node`, and can be traced directly back to `example_node` without going up any levels. (I.e., this is intuitively what you think an ancestor should be.) Every node in a binary tree shares at least one ancestor -- the root. In this exercise, write a function that takes in a BST and two nodes, and returns the node that is the lowest common ancestor of the given nodes. Assume no duplicate values.

## `next_largest`

Given a node in a Binary Search Tree, find the node with the next largest value. Assume you don't have the root of the tree, just a single node from it. Implement this function using ruby.

## `is_bst?`

Given a binary tree, write a function to check whether itâ€™s a binary search tree or not.

## `isBalancedTree`

Write a JavaScript function to check if a binary tree is balanced. A tree is balanced if, at every node, the depth of subtree on the left hand side is equal to the depth of the subtree on the right (plus or minus one). 

## [Solutions](./bst-solution.md)
